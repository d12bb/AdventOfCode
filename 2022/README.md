## My solutions to [Advent of Code](https://adventofcode.com) [2022](https://adventofcode.com/2022)
One day, one programming language..:

1. Rust. I love this language!
2. Go. if err != nil and `switch`eroo..
3. Python. I use tabs, btw.
4. C. Took me a while, glad I got this over and done with.
5. Ruby. Long time since I last used this one.
6. Clojure. If only it wasn't built on Java..
7. Lua. No off-by-one errors today.
8. VimScript. Thank goodness there's Neovim with Fennel nowadays.
9. Zig. Why Zig when there's Rust?
10. Fish. Really a more friendly shell.
11. Raku (Perl 6). `grammar` looks nice.
12. Swift. Kinda torn on this one.
13. Haskell. GHC warns when using tabs, wtf?
14. Nim. Compiled and statically-typed Python: Nice. Not allowing tabs for indention: Not nice.
15. Elixir (and Rust). Don't know why part 2 run for hours in Elixir, when the same algorithm finishes within 650ms in Rust..
16. Crystal. Basically Ruby, compiled.
17. Dart. Feels like C with modern types.
18. Racket. Try the rainbow, use a rainbow (plugin).
19. PHP. WTF.
20. D. A systems programming language with GC by default.
21. Pascal. Oh these flashbacks, learning programming with Delphi back then..
22. Odin. Feels a lot like Go. Has a much nicer name though!
23. TypeScript. Better than JS. But it's still JS...
24. Julia. Bit minimal for my taste.
25. Objective C. Objective weirdness.

### What I learned using a different language each day
* It takes time. A lot of it. Most of the languages I used, I’ve never touched before. So I had to make myself familiar with the most basic of its syntax and concepts before even starting to think about solving the day. I probably spent the same amount of time or more reading documentation as actually writing code or thinking about the problem at hand.
* It’s not easy. Easy days are still easy, while hard days get even harder as concentration is split between thinking algorithms and trying to make an unfamiliar language do what I want.
* Tooling is everything. Having a good language server or other means of help while editing makes this a lot easier, as one can just try autocompleting stuff instead of having to look for absolutely everything in the documentation.
* Some languages are harder than others. There are multiple factors for that: Obviously languages similar to ones I’m used with were easier than for example functional languages like Haskell. Also, high-level languages are easier than low-level ones. I guess difficulty of language is a highly personal thing.
* Sometimes it doesn’t work. After waiting multiple hours waiting for my Elixir implementation of day 15 part 2 to finish and debugging the hell out of it, I rewrote it in Rust, copying the algorithm exactly. The Rust version finished in less than 650 ms, and I have not the slightest idea why it didn’t work in Elixir. Somebody familiar with Elixir will probably look at it for two seconds and tell me what I’ve done wrong…
